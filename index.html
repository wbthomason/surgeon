<!DOCTYPE html>
<html>
  <head>
    <title>Automatically Transplanting Software Functionality</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='https://fonts.googleapis.com/css?family=Ubuntu|Arimo|Muli|Cabin+Condensed|Voltaire' rel='stylesheet' type='text/css'>
    <style type="text/css">
      body { font-family: 'Arimo'; }
      h1, h2, h3 {
        font-family: 'Voltaire';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .big { font-size: 48px; }
       code {
        -moz-border-radius: 5px;
        -web-border-radius: 5px;
        background: #f7f8f2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Automatically Transplanting Software Functionality
Wil Thomason

---

# overview
.big[
- What does it mean to transplant functionality?
- Why would we want to do this?
- What's done currently?
- How can we go about this?
]
---
# what?
<table>
  <tr>
<td>
  <img src="http://blog.desdelinux.net/wp-content/uploads/2014/01/pidgin.jpg" style="width:90%; float:left"/>
</td>
<td>
  <img src="arrow.gif" style="width:80%; margin-left:auto; margin-right:auto"/>
</td>
<td>
  <img src="pidgin.jpg" style="width:90%;"/>
</td>
---

<pre><code>
  void chat(int mode_val, char * message, ident * recipient) {
    switch(mode_val) {
      case UNENC_SINGLE:
        send_raw_message(message, recipient);
        break;
      case UNENC_MANY:
        while(recipient->next) {
          send_raw_message(message, recipient);
          recipient = recipient->next;
        }
        break;
      default:
        printf("No such mode!\n");
        break;
    }
  }
</code></pre>

---

<pre><code>
      char * encode(char * buffer, int len) {
        char * ret = (char *)malloc(len * sizeof(char));
        strcpy(ret, buffer);
        for(int i = 0; i < len; ++i) {
          ret[i] += 3;
        }

        return ret;
      }

      void send_encoded_message(char * message, ident * recipient) {
        char * enc_message = encode(message);
        send_raw_message(enc_message, recipient);
      }
</code></pre>

---

# why? - motivation
.big[
- Software maintenance is a pain
- Adding features is expensive
- Plenty of potential for reuse
]
---

# why? - current state of the art
.big[
- Manual
  - Implement from scratch
  - Copypasta code
]
<img src="http://cdn2.norecipes.com/wp-content/uploads/2012/10/spaghetti-recipe-5.jpg?c02f1c" style="float:right; width: 50%"/>
---

# how? - general process
.big[
- Necessary steps:
  - Localize
  - Extract
  - Retarget
  - Insert
  - Check
  - (Probably) Repeat
]

---

# how? - localization
.big[
- Genprog is good at localizing faults
- Use test cases for functionality isolation
  - One suite for regression
  - One suite for localization
- Problem: Common state
]
---

# how? - targeting
.big[
- Genprog can try mutants, but this might be slow
- Ideas:
  - Automatic copypasta
  -
]
---

# how? - translation
.big[
- Variable renaming
- Variable creation
  - When to create, and when to rename?
  - AST similarity
- Conform to recipient's API
- Resolve dependencies
]
---

<pre><code>
      char * encode(char * buffer, int len) {
        char * ret = (char *)malloc(len * sizeof(char));
        strcpy(ret, buffer);
        for(int i = 0; i < len; ++i) {
          ret[i] += 3;
        }

        return ret;
      }

      void send_encoded_message(char * message, ident * recipient) {
        char * enc_message = encode(message);
        send_raw_message(enc_message, recipient);
      }
</code></pre>

---

# who?
<img src="https://rockhall.com/media/assets/inductees/default/the-who.jpg" style="width:60%; float:right"/>
---

class: center, middle
# questions?

    </textarea>
    <script src="//gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
    </script>
    <script src="remark.language.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
          highlightStyle: 'monokai',
          highlightLanguage: 'remark'
        }) ;
    </script>
  </body>
</html>
