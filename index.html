<!DOCTYPE html>
<html>
  <head>
    <title>Automatically Transplanting Software Functionality</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='https://fonts.googleapis.com/css?family=Ubuntu|Arimo|Muli|Cabin+Condensed|Voltaire' rel='stylesheet' type='text/css'>
    <style type="text/css">
      body { font-family: 'Arial'; }
      h1, h2, h3 {
        font-family: 'Arial';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .big { font-size: 30px; }
       code {
        -moz-border-radius: 5px;
        -web-border-radius: 5px;
        background: #f7f8f2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .superscript { 
        vertical-align: super;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Automatically Transplanting Software Functionality

---

# overview
.big[
- What does it mean to transplant functionality?
- Why would we want to do this?
- How can we go about this?
- Preliminary results
]
---
# what?
<table>
  <tr>
<td>
  <img src="http://blog.desdelinux.net/wp-content/uploads/2014/01/pidgin.jpg" style="width:90%; float:left"/>
</td>
<td>
  <img src="arrow.gif" style="width:80%; margin-left:auto; margin-right:auto"/>
</td>
<td>
  <img src="pidgin.jpg" style="width:90%;"/>
</td>
---

# why? - motivation
.big[
- Software maintenance is expensive
    - Estimated to be 75% of the lifetime cost of software <sup>(1)</sup>
- Adding features is expensive
    - Estimated to be 41.25% of the lifetime cost of software <sup>(1)</sup>
- If we can automate some percentage of software enhancements, this saves companies significant money
]

.footnote[(1) http://galorath.com/software_maintenance_cost]

---

# why? - current state of the art
.big[
- Manual
  - Most feature implementations are written from scratch
  - If code from another related project is used, it requires a human developer copying and pasting the source
    - This can be tedious and error-prone <sup>(2)</sup>
]
.footnote[(2) http://www.cs.utexas.edu/users/mengna09/publications/lase-icse2013.pdf]
---

# why? - previous work
- .big[ 
While nobody has successfully created an automatic transplant system previously, there has been work on the problem/related problems]
    - [Harman, Jia, and Langdon: Babel Pidgin](http://www0.cs.ucl.ac.uk/staff/ucacbbl/gismo/Harman_2014_Babel.pdf)
    - [Harman, Langdon, and Weimer: LATIVAR](https://www.cs.virginia.edu/~weimer/p/weimer-wcre2013-re-preprint.pdf)
    - [Kim, Nam, Song, and Kim: PAR](https://www.cse.ust.hk/~hunkim/papers/kim-icse2013.pdf)

- .big[
Each of these proposals has significant shortcomings (mostly manual, just a position paper, focused on repairs), which we intend to address]
---

# why? - challenges
.big[
- How do we determine which code in the donor is important?
- How do we transform code from the donor to be compatible with the recipient?
- How do we determine where in the recipient to insert the transplant?
- How do we handle complex (multi-modification) transplants?
]
---

# how? - constraints
.big[
- Single donor
- Single transplant site (per function)
- C programs
- Human intervention as a fallback]
---

# how? - general process
.big[
- Proposed steps:
    - Find the organ in the donor
    - Extract the organ
        - Extract dependencies
        - Repackage
    - Find transplant sites in the recipient
    - Try sites
        - Templates
        - Smoothing with Genprog
    - Ask the user (maybe)
        - We prefer to be as automated as possible
]

---

# how? - organ localization
.big[
- Need to find code responsible for functionality
- Use same test suite for donor and recipient
- Find code in donor used in cases failed by recipient
]
---

# how? - organ extraction
.big[
- Dependency analysis
    - Similar to CIL's global dependency analysis
- Repackage into standalone C file & header
    - Makes transplant easier
]
---

# how? - transplant site localization
.big[
- Currently using uniform localization
    - Problem with standard Genprog fault localization being that it can't find what isn't there
- Considering slicing, etc. as alternatives
    - Not yet tested
- Semi-island GP approach
    - Try multiple sites independently, merge random pairings
- Search space:
    - `n` sites for each of `m` candidate calls
]
---

# how? - translation
.big[
- Custom mutation operator
    - Assume all data necessary are passed in
    - Section to initialize variables for parameters
    - Call to extracted function
    - Section to give return value back to recipient code
- Match to data in recipient based off of type
- Perform smoothing using standard Genprog mutations
]
---

<br/><br/><br/>

<pre><code>
    void message(char * message, ident * recipient, int type) {
        switch(type) {
            case UNENCRYPTED:
                send_message(message, recipient);
                break;
            case ENCRYPTED:
                // TODO
                break;
            }
    }
</code></pre>

---

<br/><br/><br/>

<pre><code>
      char * encode(char * buffer, int len) {
        char * ret = (char *)malloc(len * sizeof(char));
        strcpy(ret, buffer);
        for(int i = 0; i < len; ++i) {
          ret[i] += 3;
        }

        return ret;
      }

      void send_encoded_message(char * message, ident * recipient) {
        char * enc_message = encode(message);
        send_raw_message(enc_message, recipient);
      }
</code></pre>

---

<br/><br/><br/>

<pre><code>
    void message(char * message, ident * recipient, int type) {
        switch(type) {
            case UNENCRYPTED:
                send_message(message, recipient);
                break;
            case ENCRYPTED:
                char * enc_message = message;
                ident * enc_recipient = recipient;
                send_encoded_message(enc_message, enc_recipient);
                break;
            }
    }
</code></pre>

---

# preliminary results - benchmarks

.big[
- Tiered structure 
- Tier I: 
    - Bare functionality
    - Toy stack-based calculator variants
- Tier II:
    - Student programs, more realistic
    - Selection of intro class student submissions & topological sort programs
- Tier III:
    - Real-world applicability
    - Pidgin and SSL implementations]
---

# preliminary results - overview
.big[
- Tier I: 9/9 transplants succeed
- Tier II: ~60% of transplants succeed
    - Problem that transplants in this context are often closer to repairs
- Tier III: In progress
    - No successes yet - search space with uniform localization appears to be too large]
---

# conclusion

.big[
- Adding features is expensive
- Automation is less so
- By lifting and retargeting existing code, we can transplant functionality
- Genprog helps identify code to transplant; we have to translate it
]

---
class: center, middle
# questions?

    </textarea>
    <script src="//gnab.github.io/remark/downloads/remark-latest.min.js">
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>
    </script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
    </script>
    <script src="remark.language.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
          highlightStyle: 'monokai',
          highlightLanguage: 'remark'
        }) ;

MathJax.Hub.Config({
              tex2jax: {
                            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
                                          }
                             });
      MathJax.Hub.Queue(function() {
                    $(MathJax.Hub.getAllJax()).map(function(index, elem) {
                                      return(elem.SourceElement());
                                                }).parent().addClass('has-jax');
                          });

      MathJax.Hub.Configured();
    </script>
  </body>
</html>
