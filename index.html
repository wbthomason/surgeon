<!DOCTYPE html>
<html>
  <head>
    <title>Automatically Transplanting Software Functionality</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='https://fonts.googleapis.com/css?family=Ubuntu|Arimo|Muli|Cabin+Condensed|Voltaire' rel='stylesheet' type='text/css'>
    <style type="text/css">
      body { font-family: 'Arimo'; }
      h1, h2, h3 {
        font-family: 'Voltaire';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .big { font-size: 30px; }
       code {
        -moz-border-radius: 5px;
        -web-border-radius: 5px;
        background: #f7f8f2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .superscript { 
        vertical-align: super;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Automatically Transplanting Software Functionality

---

# overview
.big[
- What does it mean to transplant functionality?
- Why would we want to do this?
- How can we go about this?
- Preliminary results
]
---
# what?
<table>
  <tr>
<td>
  <img src="http://blog.desdelinux.net/wp-content/uploads/2014/01/pidgin.jpg" style="width:90%; float:left"/>
</td>
<td>
  <img src="arrow.gif" style="width:80%; margin-left:auto; margin-right:auto"/>
</td>
<td>
  <img src="pidgin.jpg" style="width:90%;"/>
</td>
---

# why? - motivation
.big[
- Software maintenance is expensive
    - Estimated to be 75% of the lifetime cost of software <sup>(1)</sup>
- Adding features is expensive
    - Estimated to be 41.25% of the lifetime cost of software <sup>(1)</sup>
- If we can automate some percentage of software enhancements, this saves companies significant money
]

.footnote[(1) http://galorath.com/software_maintenance_cost]

---

# why? - current state of the art
.big[
- Manual
  - Most feature implementations are written from scratch
  - If code from another related project is used, it requires a human developer copying and pasting the source
]
---

# why? - previous work
- .big[ 
While nobody has successfully created an automatic transplant system previously, there has been work on the problem/related problems]
    - [Harman, Jia, and Langdon: Babel Pidgin](http://www0.cs.ucl.ac.uk/staff/ucacbbl/gismo/Harman_2014_Babel.pdf)
    - [Harman, Langdon, and Weimer: LATIVAR](https://www.cs.virginia.edu/~weimer/p/weimer-wcre2013-re-preprint.pdf)
    - [Kim, Nam, Song, and Kim: PAR](https://www.cse.ust.hk/~hunkim/papers/kim-icse2013.pdf)

- .big[
Each of these proposals has significant shortcomings (mostly manual, just a position paper, focused on repairs), which we intend to address]
---

# how? - general process
.big[
- Necessary steps:
    - Find the organ in the donor
    - Extract the organ
        - Extract dependencies
        - Repackage
    - Find transplant sites in the recipient
    - Try sites
        - Templates
        - Smoothing with Genprog
    - Ask the user (maybe)
]

---

# how? - organ localization
.big[
- Need to find code responsible for functionality
- Use same test suite for donor and recipient
- Find code in donor used in cases failed by recipient
- Dependency analysis
    - Uses CIL global dependency checking
- Repackage into standalone C file & header
    - Makes transplant easier
]
---

# how? - transplant site localization
.big[
- Currently using uniform localization
    - Problem with standard Genprog fault localizationbeing that it can't find what isn't there
- Considering slicing, etc. as alternatives
    - Not yet tested
- Semi-island GP approach
    - Try multiple sites independently, merge random pairings
]
---

# how? - translation
.big[
- Custom mutation operator
    - Assume all data necessary are passed in
    - Section to initialize variables for parameters
    - Call to extracted function
    - Section to give return value back to recipient code
- Match to data in recipient based off of type
- Perform smoothing using standard Genprog mutations
]
---

<br/><br/><br/>

<pre><code>
      char * encode(char * buffer, int len) {
        char * ret = (char *)malloc(len * sizeof(char));
        strcpy(ret, buffer);
        for(int i = 0; i < len; ++i) {
          ret[i] += 3;
        }

        return ret;
      }

      void send_encoded_message(char * message, ident * recipient) {
        char * enc_message = encode(message);
        send_raw_message(enc_message, recipient);
      }
</code></pre>

---

# conclusion

.big[
- Adding features is expensive
- Automation is less so
- By lifting and retargeting existing code, we can transplant functionality
- Genprog helps identify code to transplant; we have to translate it
]

---
class: center, middle
# questions?

    </textarea>
    <script src="//gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
    </script>
    <script src="remark.language.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
          highlightStyle: 'monokai',
          highlightLanguage: 'remark'
        }) ;
    </script>
  </body>
</html>
